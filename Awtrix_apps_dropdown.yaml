blueprint:
  name: "AWTRIX Apps → Dropdown"
  description: |
    Update an input_select dropdown with discovered AWTRIX apps
    from a selected AWTRIX Custom Apps sensor.
    ## ⚠️ REQUIREMENTS ⚠️

    1.  Create an input helper: input_select.awtrix_apps
        - Go to Settings → Devices & Services → Helpers → Add Helper → Dropdown
        - Name: AWTRIX Apps
        - Options: You need to put at least one option here to create the entity.
          You can put anything you want, as it will be replaced by the automation.
        - Icon: mdi:apps
        - Save
  domain: automation
  input:
    sensor_source:
      name: AWTRIX Apps Sensor
      description: "The template sensor that tracks discovered AWTRIX apps"
      selector:
        entity:
          domain: sensor
    input_select_target:
      name: Input Select
      description: "Dropdown entity for discovered apps"
      selector:
        entity:
          domain: input_select

mode: restart

trigger:
  - platform: state
    entity_id: !input sensor_source

# Define variables from inputs for cleaner templates
variables:
  source_entity: !input sensor_source
  target_entity: !input input_select_target

action:
  - service: input_select.set_options
    target:
      entity_id: !input input_select_target # Or use "{{ target_entity }}"
    data:
      options: "{{ state_attr(source_entity, 'apps') }}"

#template sensor or BETTER an MQTT sensor:

#template:
#  - trigger:
#      # This platform listens for any message on any topic under Minibyt/custom/
#      - platform: mqtt
#        topic: "Minibyt/custom/#"
#    sensor:
#      - name: "Minibyt AWTRIX Custom Apps"
#        # The main state will be a count of the discovered apps.
#        state: "{{ this.attributes.apps | count }}"
#        attributes:
#          # This template runs each time the trigger fires.
#          apps: >
#            {# Get the app name from the end of the topic string (e.g., "Minibyt/custom/weather" -> "weather") #}
#            {% set new_app = trigger.topic.split('/')[-1] %}
#
#            {# Get the list of apps we have already found #}
#            {% set existing_apps = this.attributes.apps | default([]) %}
#            
#            {# Add the new app to the list, then filter for unique values and sort it alphabetically. #}
#            {{ (existing_apps + [new_app]) | unique | sort }}
#          last_fetch: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

#mqtt:
#  sensor:
#    - name: "Minibyt AWTRIX Apps in Loop"
#      # This sensor listens to the loop topic directly.
#      state_topic: "Minibyt/stats/loop"
#      # The state will be the count of active apps from the JSON keys.
#      value_template: "{{ value_json.keys() | list | count }}"
#      # This template extracts the list of app names from the JSON object's keys.
#      json_attributes_topic: "Minibyt/stats/loop"
#      json_attributes_template: >
#        {{ {'apps': value_json.keys() | list} | tojson }}
#        {{ {'apps': value_json.keys() | list,'last_fetch': now().strftime('%Y-%m-%d %H:%M:%S')} | tojson }}