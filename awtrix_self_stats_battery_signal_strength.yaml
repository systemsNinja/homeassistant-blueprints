blueprint:
  name: AWTRIX Device Self-Stats
  description: >-
    Displays internal device statistics on a single AWTRIX Device display as a custom app.
    Select which stats to show (WiFi, Battery, RAM, Uptime, Version) and customize the appearance.
    
    This blueprint requires your AWTRIX device to be integrated via MQTT.
  domain: automation
  author: SystemsNinja
  input:
    awtrix_device:
      name: AWTRIX Device
      description: Select the Awtrix device to display the stats on.
      selector:
        device:
          filter:
            - integration: mqtt
              manufacturer: Blueforcer
              model: AWTRIX 3

    # --- Content Selection ---
    show_wifi:
      name: Show WiFi Strength
      description: Display the current WiFi signal strength (dB).
      selector:
        boolean: {}
      default: true
    show_battery:
      name: Show Battery Level
      description: Display the current battery percentage.
      selector:
        boolean: {}
      default: true
    show_ram:
      name: Show Free RAM
      description: Display the available RAM (in Bytes).
      selector:
        boolean: {}
      default: true
    show_uptime:
      name: Show Uptime
      description: Display the device uptime.
      selector:
        boolean: {}
      default: true
    show_version:
      name: Show Firmware Version
      description: Display the current AWTRIX firmware version.
      selector:
        boolean: {}
      default: true

    # --- Configuration ---

    app_name:
      name: Custom App Name
      description: The name for the custom app topic (e.g., self-stats). This will be the last part of the MQTT topic.
      selector:
        text: {}
      default: "self-stats"
    icon_in:
      name: Icon ID
      description: Enter the Icon Name or ID (e.g., 50417 for Gear). Not used if "No Icon" is selected.
      selector:
        text:
      default: "50417"

    push_icon:
      name: Icon Behavior
      description: Select how the icon should be displayed.
      selector:
        select:
          options:
            - label: "Icon doesn't move"
              value: "0"
            - label: "Icon moves with text"
              value: "1"
            - label: "Icon moves & reappears"
              value: "2"
            - label: "No Icon"
              value: "3"
          mode: dropdown
      default: "0"
    update_unit:
      name: Update Unit
      description: Choose whether the update interval is in seconds or minutes.
      selector:
        select:
          options:
            - "seconds"
            - "minutes"
      default: "minutes"
    update_interval:
      name: Update Interval
      description: How often to send the stats to the device.
      selector:
        number:
          min: 1
          max: 59
          step: 1
          mode: slider
      default: 1
    lifetime_grace:
      name: Lifetime of the app after no update from automation
      description: >-
        Defines how long the app should stay alive after the last update.
        EX: If updating every 1 minute, and this is set to 30 seconds,
        the app will be removed 90 seconds (60s update + 30s grace) after the last update.
      selector:
        select:
          mode: dropdown
          options:
            - label: "3 seconds"
              value: "3"
            - label: "5 seconds"
              value: "5"
            - label: "10 seconds"
              value: "10"
            - label: "15 seconds"
              value: "15"
            - label: "20 seconds"
              value: "20"
            - label: "30 seconds"
              value: "30"
            - label: "45 seconds"
              value: "45"
            - label: "1 minute"
              value: "60"
            - label: "2 minutes"
              value: "120"
            - label: "3 minutes"
              value: "180"
            - label: "4 minutes"
              value: "240"
            - label: "5 minutes"
              value: "300"
            - label: "10 minutes"
              value: "600"
            - label: "30 minutes"
              value: "1800"
      default: "30"

    lifetimeMode:
      name: Lifetime Mode
      description: What happens after the app's lifetime expires.
      selector:
        select:
          options:
            - label: "Remove app from rotation"
              value: "0"
            - label: "Show a 'stale' indicator"
              value: "1"
      default: "0"

    # --- Visuals ---
    text_color:
      name: Text Color
      description: The color of the scrolling text (ignored if Rainbow Text is enabled).
      selector:
        color_rgb: {}
      default: [160, 160, 0]
    text_case:
      name: Text Case
      description: Select how you would like your text to display.
      selector:
        select:
          options:
            - label: "Use global AWTRIX setting"
              value: "0"
            - label: "Force Uppercase"
              value: "1"
            - label: "Show as is (Default)"
              value: "2"
          mode: dropdown
      default: "2"
    rainbow_text:
      name: Rainbow Text
      description: Overrides the text color and makes the text a rainbow gradient.
      selector:
        boolean: {}
      default: false
    effect:
      name: Effect
      description: The display effect to use for the background.
      selector:
        select:
          options:
            - "None"
            - "Fade"
            - "MovingLine"
            - "BrickBreaker"
            - "PingPong"
            - "Radar"
            - "Checkerboard"
            - "Fireworks"
            - "PlasmaCloud"
            - "Ripple"
            - "Snake"
            - "Pacifica"
            - "TheaterChase"
            - "Plasma"
            - "Matrix"
            - "SwirlIn"
            - "SwirlOut"
            - "LookingEyes"
            - "TwinklingStars"
            - "ColorWaves"
      default: "TwinklingStars"
    repeat_count:
      name: Scroll Repeat Count
      description: How many times the text should scroll. 0 means it scrolls until removed (default app time).
      default: 1
      selector:
        number:
          min: 0
          max: 10
          step: 1
          mode: slider

# This defines how the automation will run.
mode: single
max_exceeded: silent

# These are variables created from the user inputs for easier use in the action.
variables:
  device: !input awtrix_device
  update_unit: !input update_unit
  update_interval: !input update_interval
  show_wifi: !input show_wifi
  show_battery: !input show_battery
  show_ram: !input show_ram
  show_uptime: !input show_uptime
  show_version: !input show_version
  app_name: !input app_name
  push_icon: !input push_icon
  icon_in: !input icon_in
  text_color: !input text_color
  text_case: !input text_case
  rainbow_text: !input rainbow_text
  effect: !input effect
  lifetime_grace: !input lifetime_grace
  lifetime: >
    {% set interval = iif(update_unit == "minutes", update_interval|int * 60, update_interval|int) %}
    {{ interval + (lifetime_grace | int) }}
  lifetimeMode: !input lifetimeMode
  repeat_count: !input repeat_count

# The automation will be triggered based on a time pattern for either seconds or minutes.
trigger:
  - platform: time_pattern
    seconds: "/1"   # fires every second

condition:
  - condition: template
    value_template: >-
      {% set interval = iif(update_unit == "minutes", update_interval * 60, update_interval) %}
      {{ (as_timestamp(now()) | int) % interval == 0 }}


# This is the sequence of actions that will be performed when the automation is triggered.
action:
  # Define variables specific to the selected device.
  - variables:
      # This is the reliable way to get the device's base MQTT topic.
      # It finds the sensor that stores the topic and gets its state.
      base_topic: >
        {% set topic_entity = device_entities(device) | select('search', '_device_topic') | first %}
        {{ states(topic_entity) if topic_entity else 'unknown' }}

  # Proceed only if the base_topic was found.
  - if:
      - "{{ base_topic != 'unknown' }}"
    then:
      - variables:
          # Construct the full topic for publishing the custom app payload.
          topic: "{{ base_topic }}/custom/{{ app_name }}"
          # This block constructs the text payload by conditionally adding each selected stat.
          text_payload: >
            {% set parts = namespace(text = []) %}
            {% if show_wifi %}
              {% set wifi_state = states('sensor.' ~ base_topic ~ '_wifi_strength') %}
              {% set parts.text = parts.text + ['· WIFI ' ~ wifi_state ~ ' dB'] if wifi_state not in ['unavailable', 'unknown'] else parts.text %}
            {% endif %}
            {% if show_battery %}
              {% set battery_state = states('sensor.' ~ base_topic ~ '_battery') %}
              {% set parts.text = parts.text + ['· BATTERY ' ~ battery_state ~ ' %'] if battery_state not in ['unavailable', 'unknown'] else parts.text %}
            {% endif %}
            {% if show_ram %}
              {% set ram_state = states('sensor.' ~ base_topic ~ '_free_ram') %}
              {% set parts.text = parts.text + ['· RAM ' ~ ram_state ~ ' B'] if ram_state not in ['unavailable', 'unknown'] else parts.text %}
            {% endif %}
            {% if show_uptime %}
              {% set s = states('sensor.' ~ base_topic ~ '_uptime') | int(0) %}
              {% if s > 0 %}
                {% set days = (s / 86400) | int %}
                {% set hours = ((s % 86400) / 3600) | int %}
                {% set minutes = ((s % 3600) / 60) | int %}
                {% set uptime_str = namespace(value='') %}
                {% if days > 0 %}{% set uptime_str.value = uptime_str.value ~ days ~ 'd ' %}{% endif %}
                {% if hours > 0 %}{% set uptime_str.value = uptime_str.value ~ hours ~ 'h ' %}{% endif %}
                {% if minutes > 0 %}{% set uptime_str.value = uptime_str.value ~ minutes ~ 'm' %}{% endif %}
                {% set parts.text = parts.text + ['· UPTIME ' ~ uptime_str.value | trim] %}
              {% endif %}
            {% endif %}
            {% if show_version %}
              {% set version_state = states('sensor.' ~ base_topic ~ '_version') %}
              {% set parts.text = parts.text + ['· VER ' ~ version_state] if version_state not in ['unavailable', 'unknown'] else parts.text %}
            {% endif %}
            {{ parts.text | join('     ') }}

      # Only publish to MQTT if the text_payload is not empty.
      - if:
          - "{{ text_payload | length > 0 }}"
        then:
          # The service call to publish the data to the MQTT broker.
          - service: mqtt.publish
            data:
              qos: 0
              retain: false
              topic: "{{ topic }}"
              payload: >
                {
                  "text": "{{ text_payload }}"
                  {%- if push_icon != "3" %},
                  "icon": "{{ icon_in }}"
                  {%- endif %},
                  "pushIcon": {{ push_icon if push_icon != "3" else "0" }},
                  "textCase": {{ text_case }},
                  "effect": "{{ effect }}",
                  "repeat": {{ repeat_count }},
                  "lifetime": {{ lifetime }},
                  "lifetimeMode": {{ lifetimeMode | int }}
                  {% if rainbow_text %}
                    , "rainbow": true
                  {% else %}
                    , "color": {{ text_color | tojson }}
                  {% endif %}
                }
